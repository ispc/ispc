#!@Python3_EXECUTABLE@ -uB
#
#  Copyright (c) 2019-2020, Intel Corporation
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions are
#  met:
#
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#
#    * Neither the name of Intel Corporation nor the names of its
#      contributors may be used to endorse or promote products derived from
#      this software without specific prior written permission.
#
#
#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
#   IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
#   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
#   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
#   OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
#   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
#   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
#   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
#   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
#   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


import sys, os
import subprocess
import argparse
import re

def compareImages(image0,image1):
  if not os.path.isfile(image0) or not os.path.isfile(image1): 
    print("No such files")
    return False

  try: line = subprocess.check_output("compare -metric MAE "+image0+" "+image1+" null:", stderr=subprocess.STDOUT, shell=True)
  except subprocess.CalledProcessError as e: line = e.output

  error = float(line[line.index('(')+1:line.index(')')])
  # Temporary set max_error to 0.1 to avoid build issues
  max_error = 0.1
  if error > max_error:
    print("MAE error: " + str(error) + " is more then threshhold: " + str(max_error))
  else:
    print("Passed correctness test with max error: " + str(max_error))
  return error < max_error

parser = argparse.ArgumentParser()
parser.add_argument('dir', type=str)
parser.add_argument('exe_name', type=str)
parser.add_argument('-res_image', dest='res_image', type=str)
parser.add_argument('-ref_image', dest='ref_image', type=str)
args, unknown = parser.parse_known_args()

print("Found additional arguments: ", unknown, " Will append these to cmd line.")
print("Using [" + args.exe_name + "] test in " + args.dir)

additional_path = ""
additional_libs = ""

cmc_lib = "@CMC_LIBRARY_PATH@"
if os.name == 'nt':
    mdf_path = "@MDF_ROOT@"
    compiler_lib = cmc_lib
    runtime_lib = mdf_path + "/runtime/lib/x64"
    additional_path = os.pathsep + os.pathsep.join([compiler_lib, runtime_lib])
else:
    neo_path = "@NEO_INSTALL_PATH@"
    neo_lib = neo_path + "/neo/usr/local/lib"
    extra_lib = neo_path + "/neo/lib/extra"
    local_lib = "/usr/local/lib"
    additional_libs = os.pathsep + os.pathsep.join([neo_lib, extra_lib, local_lib])

test_env = os.environ.copy()
test_env["PATH"] += additional_path
test_env["LD_LIBRARY_PATH"] = additional_libs

cur_dir = os.path.dirname(os.path.realpath(__file__))
test_dir = os.path.join(cur_dir, str(args.dir))

host_name = args.exe_name
executable = os.path.join(test_dir, host_name)

cmd = [executable] + unknown

print("Using host name: ", host_name)
print("Attempting to access executable at: ", executable)

success = re.compile(r'passed', re.IGNORECASE)

try:
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, env=test_env, cwd=test_dir)
    out, err = p.communicate()
    print(out)
    if not success.search(out.decode()):
        sys.exit(-1)
    if args.res_image and args.ref_image:
        if not compareImages(os.path.join(test_dir, args.res_image ), os.path.join(test_dir, args.ref_image)):
            sys.exit(-1)
except subprocess.CalledProcessError as e:
    print("Return code is ", p.returncode)
    print(e.message)
    sys.exit(p.returncode)
