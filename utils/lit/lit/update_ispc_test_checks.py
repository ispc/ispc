#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Update ISPC tests with FileCheck assertions for both ASM and LLVM IR.

Behavior summary:
- Supports both `// RUN:` and `//; RUN:` style (plus /* RUN: ... */ variants).
- Detects ISPC ASM runs (`--emit-asm` or `-S`) and generates `// CHECK_*` using
  UpdateTestChecks.asm.
- Detects ISPC IR runs (`--emit-llvm-text` or `--emit-llvm`) and generates
  `// CHECK_*` blocks based on the LLVM IR output, similar in spirit to
  update_test_checks / opt-based tests.
- Removes old `// CHECK...` and `//; CHECK...` lines for active prefixes.
- Maps `--target=...` to a reasonable LLVM triple for the ASM scrubber.
- Normalizes `%{ispc}` to $ISPC or `ispc` when running outside LIT.
- Always runs ISPC on the file path, not via stdin (no `< %s` / `-` magic).
- All autogenerated comments use `//` (no `;` or `// ;` comment prefixes).
- CHECK blocks are emitted above functions, not inside function bodies.
"""

from __future__ import print_function

import argparse
import os
import re
import sys
from sys import stderr
from traceback import print_exc

from UpdateTestChecks import common
from UpdateTestChecks import asm as asm_output

# ---------------------------------------------------------------------------
# ISPC RUN detection helpers
# ---------------------------------------------------------------------------

MODE_ASM = "asm"
MODE_IR = "ir"

ISPC_ASM_FLAGS = ("--emit-asm", "-S")
ISPC_IR_FLAGS = ("--emit-llvm-text")

# All autogenerated comments must start with //, never ; or //;
COMMENT_PREFIX_ASM = "//"    # for backend asm checks
COMMENT_PREFIX_IR = "//"     # for IR checks

RUN_LINE_PATTERNS = [
    re.compile(r"^\s*//\s*RUN:\s*(.+)$"),
    re.compile(r"^\s*//;\s*RUN:\s*(.+)$"),
    re.compile(r"^\s*/\*\s*RUN:\s*(.+?)\s*\*/\s*$"),
    re.compile(r"^\s*/\*;\s*RUN:\s*(.+?)\s*\*/\s*$"),
]


def _strip_comment_prefix(line: str) -> str:
    """Remove comment delimiters for continued RUN lines."""
    line = re.sub(r'^\s*//;?\s*', '', line)
    line = re.sub(r'^\s*/\*;?\s*', '', line)
    line = re.sub(r'\s*\*/\s*$', '', line)
    return line


def _collect_run_lines(ti) -> list:
    """Return a list of logical RUN commands (after handling backslash continuations)."""
    runs = []
    i, n = 0, len(ti.input_lines)
    while i < n:
        raw = ti.input_lines[i]
        matched = None
        for pat in RUN_LINE_PATTERNS:
            m = pat.match(raw)
            if m:
                matched = m.group(1).rstrip()
                break
        if matched is None:
            i += 1
            continue

        acc = matched
        # Join lines ending with '\' using the same comment prefix logic as in LLVM scripts.
        while acc.endswith("\\") and i + 1 < n:
            acc = acc[:-1]
            i += 1
            cont = _strip_comment_prefix(ti.input_lines[i]).rstrip()
            acc += cont
        runs.append(acc)
        i += 1

    return runs


def _is_ispc_asm_cmd(cmd: str) -> bool:
    toks = cmd.strip().split()
    if not toks:
        return False
    tool = toks[0]
    if not (tool.endswith("ispc") or tool == "%{ispc}"):
        return False
    return any(flag in toks for flag in ISPC_ASM_FLAGS)


def _is_ispc_ir_cmd(cmd: str) -> bool:
    toks = cmd.strip().split()
    if not toks:
        return False
    tool = toks[0]
    if not (tool.endswith("ispc") or tool == "%{ispc}"):
        return False
    return any(flag in toks for flag in ISPC_IR_FLAGS)


def _is_filecheck_cmd(s: str) -> bool:
    first = s.strip().split(" ", 1)[0]
    return first == "FileCheck" or first == "%{FileCheck}" or "FileCheck" in first


def _normalize_ispc_tool(tool: str) -> str:
    """Resolve lit-style %{ispc} placeholder to a real binary."""
    if tool == "%{ispc}":
        env = os.environ.get("ISPC")
        if env:
            return env
        return "ispc"
    return tool


# ---------------------------------------------------------------------------
# ISPC --target=... → LLVM triple mapping (for asm scrubber)
# ---------------------------------------------------------------------------

_TARGET_RE = re.compile(r"--target=([^\s]+)")


def _triple_from_ispc_args(tool_args: str) -> str:
    """
    Heuristic mapping from ISPC --target=... to LLVM triple, for use by asm scrubber.
    """
    m = _TARGET_RE.search(tool_args)
    if not m:
        return "x86_64-unknown-linux-gnu"

    tgt = m.group(1).lower()

    # x86 family
    if tgt.startswith(("avx", "sse")) or "x86" in tgt:
        return "x86_64-unknown-linux-gnu"
    if tgt.startswith("avx512"):
        return "x86_64-unknown-linux-gnu"

    # AArch64 / ARM
    if tgt.startswith(("aarch64", "arm64")):
        return "aarch64-unknown-linux-gnu"
    if tgt.startswith(("neon", "armv7", "arm")):
        return "armv7-none-linux-gnueabihf"

    # WebAssembly
    if "wasm" in tgt:
        return "wasm32-unknown-unknown"

    # Fallback
    return "x86_64-unknown-linux-gnu"


# ---------------------------------------------------------------------------
# Regexes for ISPC function headers and FileCheck lines
# ---------------------------------------------------------------------------

ISPC_FUNCTION_RE = re.compile(
    r"""^\s*
        (?:export\s+)?                 # optional 'export'
        (?:task\s+)?                   # optional 'task'
        (?:inline\s+)?                 # optional 'inline'
        (?:static\s+)?                 # optional 'static'
        (?:uniform|varying)?\s*        # optional qualifier
        [A-Za-z_][\w\s\*\[\]<>\.:,]*   # return type-ish
        \s+([A-Za-z_]\w*)              # function name (group 1)
        \s*\(
    """,
    re.X,
)

# CHECK line: // CHECK_SSE4-LABEL: ..., or // CHECK,CHECK_SSE4-NEXT: ...
CHECK_LINE_RE = re.compile(
    r'^\s*//;?\s*([A-Za-z0-9_,]+)'
    r'(?:-(?:NEXT|NOT|DAG|LABEL|SAME|EMPTY|COUNT-\d+))?:'
)


# ---------------------------------------------------------------------------
# IR helper: use LLVM's OPT_FUNCTION_RE and do fuzzy matching on name
# ---------------------------------------------------------------------------

def _find_ir_function(ir_text: str, src_name: str):
    """
    Find the IR function that corresponds to the given ISPC source function name.

    Matching strategy:
      1. Prefer exact match: ir_name == src_name.
      2. Then prefix match: ir_name.startswith(src_name).
      3. Then substring match: src_name in ir_name (to handle mangling like `_Z11draw_rectsf`).
    """
    best_exact = None
    best_prefix = None
    best_sub = None

    for m in common.OPT_FUNCTION_RE.finditer(ir_text):
        ir_name = m.group("func")
        args_and_sig = m.group("args_and_sig")
        body = m.group("body")
        body_lines = [ln.rstrip() for ln in body.splitlines()]
        record = (ir_name, args_and_sig, body_lines)

        if ir_name == src_name:
            best_exact = record
            break
        if ir_name.startswith(src_name) and best_prefix is None:
            best_prefix = record
        if src_name in ir_name and best_sub is None:
            best_sub = record

    if best_exact:
        return best_exact
    if best_prefix:
        return best_prefix
    if best_sub:
        return best_sub
    return None


def _emit_ir_checks_for_function(output_lines, ir_text, func_name, prefixes):
    """
    Emit IR CHECK lines into output_lines for a single ISPC function.
    Uses LLVM's OPT_FUNCTION_RE and keeps IR quite literally, with CHECK-LABEL and CHECK-NEXT.
    """
    match = _find_ir_function(ir_text, func_name)
    if not match:
        return

    ir_name, args_and_sig, body_lines = match
    arg_sig = args_and_sig.strip()

    for prefix in prefixes:
        # Header – mimic update_test_checks style, but with '//' instead of ';'.
        if arg_sig:
            output_lines.append(
                f"{COMMENT_PREFIX_IR} {prefix}-LABEL: define {{.*}} @{ir_name}{arg_sig}"
            )
        else:
            output_lines.append(
                f"{COMMENT_PREFIX_IR} {prefix}-LABEL: define {{.*}} @{ir_name}("
            )

        first_emitted = False
        for line in body_lines:
            stripped = line.strip()
            if not stripped:
                continue
            if stripped.startswith("attributes #"):
                # Skip attribute table at the end.
                continue
            if not first_emitted:
                first_emitted = True
            # Do not touch IR contents (things like '; preds = %for_loop' must stay).
            output_lines.append(f"{COMMENT_PREFIX_IR} {prefix}-NEXT: {stripped}")
    # Note: we don't add an extra blank line here; spacing is normalized globally later.


# ---------------------------------------------------------------------------
# Parsing RUN lines into structured info
# ---------------------------------------------------------------------------

def _build_run_list(ti):
    """
    Parse RUN lines and build:
      run_list = [
        (check_prefixes, tool, tool_args_for_ispc, preprocess_cmd, mode, triple)
      ]
    """
    run_list = []

    for l in _collect_run_lines(ti):
        if "|" not in l:
            common.warn("Skipping unparsable RUN line: " + l)
            continue

        commands = [cmd.strip() for cmd in l.split("|")]
        if len(commands) < 2:
            continue

        preprocess_cmd = None
        if len(commands) > 2:
            # Everything before the last two pipeline elements is considered preprocessing.
            preprocess_cmd = " | ".join(commands[:-2])

        penultimate = commands[-2]
        filecheck_cmd = commands[-1]

        if not _is_filecheck_cmd(filecheck_cmd):
            common.warn("Skipping non-FileChecked RUN line: " + l)
            continue

        # Mode detection
        if _is_ispc_asm_cmd(penultimate):
            mode = MODE_ASM
        elif _is_ispc_ir_cmd(penultimate):
            mode = MODE_IR
        else:
            common.warn("Skipping non-ISPC ASM/IR RUN line: " + l)
            continue

        # Extract FileCheck prefixes
        common.verify_filecheck_prefixes(filecheck_cmd)
        check_prefixes = common.get_check_prefixes(filecheck_cmd)

        # Split tool + args
        toks = penultimate.split()
        tool = toks[0]
        tool_args = " ".join(toks[1:])

        # Normalize ISPC binary placeholder.
        tool = _normalize_ispc_tool(tool)

        # Normalize input file handling:
        #  - remove `< %s`
        #  - replace bare `%s` with the actual test path
        #  - do NOT feed ISPC from stdin; always compile ti.path directly
        tool_args = tool_args.replace("< %s", "").strip()
        tool_args = tool_args.replace("%s", ti.path).strip()

        # Collapse excessive whitespace.
        tool_args = re.sub(r"\s+", " ", tool_args).strip()

        # Triple only needed for ASM scrubber
        triple = None
        if mode == MODE_ASM:
            triple = _triple_from_ispc_args(tool_args)

        run_list.append((check_prefixes, tool, tool_args, preprocess_cmd, mode, triple))

    return run_list


# ---------------------------------------------------------------------------
# Main per-file update logic
# ---------------------------------------------------------------------------

def update_test(ti: common.TestInfo):
    run_list = _build_run_list(ti)

    if not run_list:
        raise RuntimeError(
            "No ISPC ASM/IR RUN lines found.\n"
            "Expected penultimate stage like:\n"
            "  %{ispc} ... --emit-asm (or -S) ... | FileCheck %s\n"
            "  or\n"
            "  %{ispc} ... --emit-llvm[-text] ... | FileCheck %s\n"
            "The script accepts your nonstandard '//; RUN:' and joins '\\' continuations."
        )

    ir_runs = [r for r in run_list if r[4] == MODE_IR]
    asm_runs = [r for r in run_list if r[4] == MODE_ASM]

    prefix_set = set(prefix for (prefixes, _, _, _, _, _) in run_list for prefix in prefixes)

    # -----------------------------------------------------------------------
    # 1. Gather ASM function bodies via FunctionTestBuilder + asm scrubber.
    # -----------------------------------------------------------------------
    ginfo = common.make_asm_generalizer(version=1)

    builder_run_list = [
        (prefixes, f"{tool} {tool_args}", preprocess_cmd)
        for (prefixes, tool, tool_args, preprocess_cmd, _, _) in run_list
    ]

    builder = common.FunctionTestBuilder(
        run_list=builder_run_list,
        flags=type(
            "",
            (object,),
            {
                "verbose": ti.args.verbose,
                "filters": ti.args.filters,
                "function_signature": False,
                "check_attributes": False,
                "replace_value_regex": [],
            },
        ),
        scrubber_args=[ti.args],
        path=ti.path,
        ginfo=ginfo,
    )

    # Run ASM passes through builder; IR handled separately.
    for (prefixes, tool, tool_args, preprocess_cmd, mode, triple) in asm_runs:
        invoke_tool = tool
        common.debug(f"Extracted ISPC ASM cmd: {invoke_tool} {tool_args}")
        common.debug(f"Extracted FileCheck prefixes: {prefixes}")
        raw_tool_output = common.invoke_tool(
            invoke_tool,
            tool_args,
            ti.path,
            preprocess_cmd=preprocess_cmd,
            verbose=ti.args.verbose,
        )

        scrubber, function_re = asm_output.get_run_handler(triple)
        if 0 == builder.process_run_line(function_re, scrubber, raw_tool_output, prefixes):
            common.warn(
                "Couldn't match any function in ASM output for prefixes {}. "
                "Ensure ISPC emits assembly for them.".format(prefixes)
            )
        builder.processed_prefixes(prefixes)

    func_dict = builder.finish_and_get_func_dict()
    global_vars_seen_dict = {}

    # -----------------------------------------------------------------------
    # 2. Run IR-producing ISPC commands and keep IR output for IR checks.
    # -----------------------------------------------------------------------
    ir_runs_outputs = []  # list of (prefixes, ir_text) per IR RUN

    if ir_runs:
        for (prefixes, tool, tool_args, preprocess_cmd, _mode, _triple) in ir_runs:
            invoke_tool = tool
            common.debug(f"Extracted ISPC IR cmd: {invoke_tool} {tool_args}")
            common.debug(f"Extracted FileCheck prefixes: {prefixes}")
            ir_text = common.invoke_tool(
                invoke_tool,
                tool_args,
                ti.path,
                preprocess_cmd=preprocess_cmd,
                verbose=ti.args.verbose,
            )

            ir_runs_outputs.append((prefixes, ir_text))

    # -----------------------------------------------------------------------
    # 3. ISPC symbol aliasing: foo1___uniuni / foo1.suffix -> foo1
    # -----------------------------------------------------------------------

    def _add_ispc_symbol_aliases(_fdict: dict):
        patterns = [
            re.compile(r'^(?P<base>[A-Za-z_]\w*)___.*$'),
            re.compile(r'^(?P<base>[A-Za-z_]\w*)\..*$'),
        ]
        for prefix, fmap in list(_fdict.items()):
            new_entries = {}
            for name, info in fmap.items():
                base = None
                for pat in patterns:
                    m = pat.match(name)
                    if m:
                        base = m.group('base')
                        break
                if base and base not in fmap:
                    new_entries[base] = info
            if new_entries:
                fmap.update(new_entries)

    _add_ispc_symbol_aliases(func_dict)

    # -----------------------------------------------------------------------
    # 4. Rebuild the .ispc file, injecting IR and ASM checks ABOVE functions.
    # -----------------------------------------------------------------------

    output_lines = []

    def _is_old_check_line(line: str) -> bool:
        """Return True if this line is any FileCheck directive (CHECK*), regardless of prefix."""
        m = CHECK_LINE_RE.match(line)
        if not m:
            return False

        prefixes_str = m.group(1)  # e.g. "CHECK_SSE4" or "CHECK,CHECK_SSE4" or "RUN"
        for p in prefixes_str.split(','):
            if "CHECK" in p:
                # Treat anything with CHECK in the prefix as a FileCheck line to be removed.
                return True

        # e.g. "RUN" will not match, so RUN lines are preserved.
        return False


    # ASM run list for asm_output.add_checks.
    if asm_runs:
        asm_run_list = [
            (pfxs, tool_args, preprocess_cmd)
            for (pfxs, _tool, tool_args, preprocess_cmd, mode, _tr)
            in asm_runs
            if mode == MODE_ASM
        ]
    else:
        asm_run_list = []

    for input_info in ti.iterlines(output_lines):
        line = input_info.line

        # 1) Drop old CHECK lines for active prefixes anywhere in the file.
        if _is_old_check_line(line):
            continue

        # 2) Detect start of an ISPC function.
        m = ISPC_FUNCTION_RE.match(line)
        if not m:
            # Not a function line, just keep it.
            output_lines.append(line)
            continue

        func_name = m.group(1)

        # 3) Build new IR and ASM checks for this function, ABOVE the function.
        new_checks = []

        # 3.a IR checks – one block per IR RUN.
        for (prefixes, ir_text) in ir_runs_outputs:
            _emit_ir_checks_for_function(new_checks, ir_text, func_name, prefixes)

        # 3.b ASM checks, if any ASM runs exist.
        if asm_run_list:
            # Add a blank line between IR CHECK block(s) and ASM CHECK block(s),
            # but only if we actually emitted some IR checks.
            if new_checks and new_checks[-1].strip() != "":
                new_checks.append("")

            asm_output.add_checks(
                new_checks,
                COMMENT_PREFIX_ASM,  # "//"
                asm_run_list,
                func_dict,
                func_name,
                ginfo,
                global_vars_seen_dict,
                is_filtered=builder.is_filtered(),
            )

        # Emit new checks first, then the function definition line itself.
        output_lines.extend(new_checks)
        output_lines.append(line)

    # -----------------------------------------------------------------------
    # 5. Final NOTE normalization + blank line compaction
    # -----------------------------------------------------------------------
    NOTE_MARK = "NOTE: Assertions have been autogenerated by utils/update_ispc_test_checks.py"

    first_note_payload = None
    body_lines = []

    for l in output_lines:
        stripped = l.lstrip()
        if NOTE_MARK in stripped:
            if first_note_payload is None:
                idx = stripped.find("NOTE:")
                if idx >= 0:
                    first_note_payload = stripped[idx:]  # "NOTE: ...."
            # skip all NOTE lines in body
            continue
        body_lines.append(l)

    final_lines = body_lines
    if first_note_payload is not None:
        final_lines = [f"// {first_note_payload}"] + body_lines

    # Compact blank lines: allow at most a single blank line in a row.
    compacted = []
    blank_streak = 0
    for l in final_lines:
        if l.strip() == "":
            if blank_streak == 0:
                compacted.append(l)
            blank_streak += 1
        else:
            blank_streak = 0
            compacted.append(l)

    final_lines = compacted

    common.debug("Writing %d lines to %s..." % (len(final_lines), ti.path))
    with open(ti.path, "wb") as f:
        f.writelines([("{}\n".format(l)).encode("utf-8") for l in final_lines])


# ---------------------------------------------------------------------------
# CLI entry point
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--filters", nargs="*", default=[])
    parser.add_argument("tests", nargs="+")
    initial_args = common.parse_commandline_args(parser)

    script_name = os.path.basename(__file__)
    returncode = 0

    for ti in common.itertests(initial_args.tests, parser, script_name="utils/" + script_name):
        if not ti.path.lower().endswith(".ispc"):
            common.warn("Skipping non-ISPC file: " + ti.path)
            continue

        try:
            update_test(ti)
        except Exception:
            stderr.write(f"Error: Failed to update test {ti.path}\n")
            print_exc()
            returncode = 1

    return returncode


if __name__ == "__main__":
    sys.exit(main())
